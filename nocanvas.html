<!DOCTYPE html>
<html>
<head>
<title>Target Practice</title>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script type="application/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script type="application/javascript" src="js/angular.min.js"></script>
<script type="application/javascript" src="js/angular-messages.min.js"></script>
<script type="application/javascript">
angular.module("myApp", ["ngMessages"]);

var game = {};
game.width=1000;
game.height=700;
game.started=false;
game.start=0;
game.end=0;
game.score=0;
game.hits=0;
game.inactive_hits=0;
game.missed=0;

var turret={};
turret.width=22;
turret.length=200;
turret.angle=90;
turret.x=game.width / 2;
// offset (0 = edge of game field, 0.5 = half-way outside game field, 1 = fully outside gamefield) 
// value of 0 you can see the edge of turret when it rotates, 0.5 is MOST EFFECTIVE for hiding this, and > 0.5 is not needed
// and negative value moves it further inside the game field
turret.offset=0.5;
//turret.width / 2 because 0 is the edge of the screen, but in order for the shots to align with the turret, the transform of the turret moves it away from the edge
// turret width of 20 with a bottom-position of -10 (move down 20/2) moves the turret to the edge (i.e., 0)
// so moving it down one more half of turret width 10 (20/2), allows us to hide the bottom edge of turret in the game's border when it rotates
turret.y=0 - (turret.width * turret.offset);
turret.ammo=30;

var shot={};
shot.width=22;
shot.height=22;
shot.speed=4;

var target={};
target.border_width=2;
target.border_color="#000";
target.background_color="rgba(255, 255, 255, 0.5)";
target.width=200;
target.height=50;

// calculate starting position of shot based off of turret's current position
function calculate_shot()
{

  var angle = turret.angle / 180 * Math.PI;
  
  shot.x = game.width - (turret.length * Math.cos(angle) + turret.x) - (shot.width / 2);
  shot.y = game.height - (turret.length * Math.sin(angle) + turret.y) - (shot.height / 2);

}

$(document).ready(function()
{

  $("#game_frame, #game, #gameover")
    .width(game.width)
    .height(game.height);

  $("#turret")
    .width(turret.length)
    .height(turret.width)
    .css(
      {
        "bottom": -1 * (turret.width * (turret.offset + 0.5)) + "px",
        "left": game.width/2 - turret.length + "px"
      });
      
  $.each($(".target"), function(index, value)
  {
    $(this)
      .data(
        {
          "prev_hit": false,
          "timeout": 10000,
          "speed": Math.random()*10+2,
          "max": false,
          "value": (($(".target").length-index-1)*3+1),
          "value": Math.pow(2, ($(".target").length-index-1))
        })
      .css(
        {
          "top": index*60 + "px",
          "border": target.border_width + "px solid " + target.border_color,
          "background-color": target.background_color,
          "width": target.width,
          "height": target.height
        })
      .html($(this).data("value"));
  });

  $(document).keydown(function(e)
  {
      
  
    if(e.keyCode==87)
      turret.length += 10;
    else if(e.keyCode==83)
      turret.length -= 10;
    else if(e.keyCode==38)
      turret.offset -= .5
    else if(e.keyCode==40)
      turret.offset += .5
    // [enter] to start game
    if(e.keyCode == 13)
    {
      if(!game.started)
      {
        $("#message").hide();
        $("#turret").show();
        $("#targets").show();
        $("#ammo").show();
        $("#score").show();
        game.started=true;
        game.start=new Date();
        animate();
      } 
    }
    // [left arrow] to decrease angle of turret
    else if(e.keyCode==37)
    {
      if(!game.paused && game.started)
        turret.angle -= 5;
    }
    // [right arrow] to increase angle of turret
    else if(e.keyCode==39)
    {
      if(!game.paused && game.started)
        turret.angle += 5;
    }
    // [f] to shoot
    else if(e.keyCode==70)
    {
      if(!game.paused && game.started && turret.ammo > 0)
      {
      
        turret.ammo--;
      
        // calculate starting position of shot
        calculate_shot();
        
        // create and append shot
        $("<div>")
          .addClass("bullet")
          .css("left", shot.x+"px")
          .css("top", shot.y+"px")
          .width(shot.width)
          .height(shot.height)
          .data("angle", turret.angle)
          .appendTo($("#game"));
      }
    }
    // [p] to pause game
    else if(e.keyCode==80)
    {
      if(game.started)
      {
        game.paused=!game.paused;
        if(!game.paused)
        {
          $("#pause").hide();
          animate();
        }
        else
          $("#pause").show();
      }
    }
  
    // limit degree of turret
    if(turret.angle <= 20)
      turret.angle = 20;
    else if(turret.angle >= 160)
      turret.angle = 160;
  
    turret.y=0 - (turret.width * turret.offset);
    $("#turret")
      .width(turret.length)
      .height(turret.width)
      .css
        ({
          "bottom": -1 * (turret.width * (turret.offset + 0.5)) + "px",
          "left": game.width/2 - turret.length + "px"
        });
    $("#turret").css("transform", "rotate(" + turret.angle + "deg)");
    
  });
  /*
  .mousemove(function(e)
  {
  
    var offset = $("#game").offset();
    $(".target").css(
    {
      "left": (e.clientX - offset.left),
      "top": (e.clientY - offset.top)
    });
  
  });
  */

});
</script>
</head>

<body>

<div id="game_frame"></div>

<div id="game">
  
  <div id="message">
    <p>
      Goal: score points according to target value
      <br>
      (hitting an inactive target won't increase score)
    </p>
    <p>
      Press <u>ENTER</u> to start game
      <br>
      Press <u>P</u> to pause game
    </p>
    <p>
      Press <u>LEFT</u> and <u>RIGHT</u> arrow keys to adjust turret
      <br>
      Press <u>F</u> to fire at targets
    </p>
  </div>
  
  <div id="pause">PAUSED</div>
  
  <div id="turret"></div>
  
  <div id="targets">
    <div class="target"></div>
    <div class="target"></div>
    <div class="target"></div>
    <div class="target"></div>
    <div class="target"></div>
    <div class="target"></div>
    <div class="target"></div>
  </div>
  
  <div id="score">Score: <span class="score">0</span></div>
  <div id="ammo">Ammo: <span class="ammo">30</span></div>

</div>

<div id="gameover">

  <form name="myForm" ng-app="myApp">
    <p style="background: #fff; color: #1e5a97;">Game Over</p>
    
    <p>
      Enter your initials
      <br>
      <input maxlength="3" type="text" name="initials" ng-pattern="/^[A-Za-z]*$/" ng-maxlength="3" ng-minlength="1" ng-model="initials" style="text-transform: uppercase;">
    </p>
    
    <p>
      Score: <span class="score">0</span>
      <br>
      Hits: <span class="hits">0</span>
      <br>
      Inactive Hits: <span class="inactive_hits">0</span>
      <br>
      Missed: <span class="missed">0</span>
      <br>
      Time: <span class="time">0s</span>
    </p>
    
    <p>
      <input type="submit" value="Submit Score">
    </p>
    
    <div style="position: absolute; bottom: 0; left: 0; right: 0; margin: auto;" ng-messages="myForm.initials.$error" role="alert">
      <div ng-message="pattern">Only use letters for initials</div>
      <div ng-message="maxlength">Maximum of 3 characters</div>
      <div ng-message="minlength">Minimum of 1 character</div>
    </div>
    
  </form>

</div>

<script type="application/javascript">
var request_frame = (function(callback)
{
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {window.setTimeout(callback, 1000 / 60);};
})();

function animate()
{

  if(game.paused)
  {
    return;
  }

  $(".target").each(function()
  {
  
    target.x = (parseFloat($(this).css("left")));
  
    var speed = $(this).data("speed");
    var timeout = new Date() - $(this).data("timeout");
  
    // don't move for 3 seconds after target has been hit
    if(timeout >= 3000)
    {
      // allow target to be hit again to increase score
      $(this)
        .data("prev_hit", false)
        .css("background-color", "rgba(255, 255, 255, 0.5");
      
      if($(this).data("max"))
      {
        if(target.x - speed <= 0)
        {
          $(this).css("left", 0);
          $(this).data(
          {
            "max": false,
            "speed": Math.random()*10+2
          });
        }
        else
          $(this).css("left", "-=" + speed);   
      }
      else
      {
        if(target.x+target.width + speed + (target.border_width * 2) >= game.width)
        {
          $(this).css("left", game.width - target.width - (target.border_width * 2));
          $(this).data(
          {
            "max": true,
            "speed": Math.random()*10+2
          });
        }
        else
          $(this).css("left", "+=" + speed);
      }
    }

  });

  $(".bullet").each(function()
  {

    var angle = $(this).data("angle") / 180 * Math.PI;
    
    $(this).css(
    {
      "left": "-=" + (Math.cos(angle) * shot.speed),
      "top": "-=" + (Math.sin(angle) * shot.speed)
    });
    
    var x = (parseFloat($(this).css("left")));
    var y = (parseFloat($(this).css("top")));
    
    
    // offset needed for top and left because that's where the origin is located
    var hit =
    // top boundary
    ((y + shot.height) <= 0) ||
    // bottom boundary
    ((y) >= game.height) ||
    // left boundary
    ((x + shot.width) <= 0) ||
    // right boundary
    ((x) >= game.width);

    if(hit)
      game.missed++;

    // calculate shot hitting a target if it hasn't already hit a boundary
    if(!hit)
    {
      $(".target").each(function()
      {
  
        target.x = (parseFloat($(this).css("left")));
        target.y = (parseFloat($(this).css("top")));
        
        var target_hit = ( ((x + shot.width) >= target.x ) && (x <= (target.x + target.width) ) ) && ( ((y + shot.height) >= target.y)  &&  (y <= (target.y + target.height))  );
      
        if(target_hit)
        {
          // initialize time for target inactivity (even if it gets hit again when inactive, but it won't increase score)
          $(this).data("timeout", new Date());
          
          // don't increase score if target is in inactive state
          //[update] adjust score according to target hit
          if(!$(this).data("prev_hit"))
          {
            game.score+=$(this).data("value");
            game.hits++;
          }
          else
            game.inactive_hits++;
            
          // assign prev_hit value
          $(this)
            .data("prev_hit", true)
            .css("background-color", "rgba(0, 0, 0, 0.5)");
        }
      
        hit = hit || target_hit;
      
      });
    }
    
    
    
    if(hit)
      $(this).remove();

  });

  $(".ammo").html(turret.ammo);
  $(".score").html(game.score);
  
  if(turret.ammo == 0 && $(".bullet").length == 0)
  {
    game.end=new Date();
    
    $(".hits").html(game.hits);
    $(".inactive_hits").html(game.inactive_hits);
    $(".missed").html(game.missed);
    $(".time").html(get_time(game.start, game.end));
    
    $("#gameover").show();
    return;
  }

  request_frame(function()
  {
    animate();
  });

}

var second = 1000;
var minute = second * 60;
var hour = minute * 60;

// determine time between two date objects
function get_time(begin, end)
{

  var elapsed = end - begin;
  if(elapsed >= hour)
    return parseInt(elapsed / hour) + "h" + parseInt(elapsed % hour / minute) + "m" + parseInt(elapsed % minute / second) + "s";
  else if(elapsed >= minute)
    return parseInt(elapsed / minute) + "m" + parseInt(elapsed % minute / second) + "s";
  else
    return parseInt(elapsed / second) + "s";

}
</script>

</body>
</html>